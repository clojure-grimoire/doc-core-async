{:ns "clojure.core.async", :name "pipeline", :file "clojure/core/async.clj", :type :fn, :src "(defn pipeline\n  \"Takes elements from the from channel and supplies them to the to\n  channel, subject to the transducer xf, with parallelism n. Because\n  it is parallel, the transducer will be applied independently to each\n  element, not across elements, and may produce zero or more outputs\n  per input.  Outputs will be returned in order relative to the\n  inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes. Note this\n  should be used for computational parallelism. If you have multiple\n  blocking operations to put in flight, use pipeline-blocking instead,\n  If you have multiple asynchronous operations to put in flight, use\n  pipeline-async instead.\"\n  ([n to xf from] (pipeline n to xf from true))\n  ([n to xf from close?] (pipeline n to xf from close? nil))\n  ([n to xf from close? ex-handler] (pipeline* n to xf from close? ex-handler :compute)))", :column 1, :line 500, :arglists ([n to xf from] [n to xf from close?] [n to xf from close? ex-handler]), :doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the transducer xf, with parallelism n. Because\n  it is parallel, the transducer will be applied independently to each\n  element, not across elements, and may produce zero or more outputs\n  per input.  Outputs will be returned in order relative to the\n  inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes. Note this\n  should be used for computational parallelism. If you have multiple\n  blocking operations to put in flight, use pipeline-blocking instead,\n  If you have multiple asynchronous operations to put in flight, use\n  pipeline-async instead."}
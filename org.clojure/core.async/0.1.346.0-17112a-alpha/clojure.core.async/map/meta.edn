{:ns "clojure.core.async", :name "map", :file "clojure/core/async.clj", :type :fn, :src "(defn map\n  \"Takes a function and a collection of source channels, and returns a\n  channel which contains the values produced by applying f to the set\n  of first items taken from each source channel, followed by applying\n  f to the set of second items from each channel, until any one of the\n  channels is closed, at which point the output channel will be\n  closed. The returned channel will be unbuffered by default, or a\n  buf-or-n can be supplied\"\n  ([f chs] (map f chs nil))\n  ([f chs buf-or-n]\n     (let [chs (vec chs)\n           out (chan buf-or-n)\n           cnt (count chs)\n           rets (object-array cnt)\n           dchan (chan 1)\n           dctr (atom nil)\n           done (mapv (fn [i]\n                         (fn [ret]\n                           (aset rets i ret)\n                           (when (zero? (swap! dctr dec))\n                             (put! dchan (java.util.Arrays/copyOf rets cnt)))))\n                       (range cnt))]\n       (go-loop []\n         (reset! dctr cnt)\n         (dotimes [i cnt]\n           (try\n             (take! (chs i) (done i))\n             (catch Exception e\n               (swap! dctr dec))))\n         (let [rets (<! dchan)]\n           (if (some nil? rets)\n             (close! out)\n             (do (>! out (apply f rets))\n                 (recur)))))\n       out)))", :column 1, :line 864, :arglists ([f chs] [f chs buf-or-n]), :doc "Takes a function and a collection of source channels, and returns a\n  channel which contains the values produced by applying f to the set\n  of first items taken from each source channel, followed by applying\n  f to the set of second items from each channel, until any one of the\n  channels is closed, at which point the output channel will be\n  closed. The returned channel will be unbuffered by default, or a\n  buf-or-n can be supplied"}
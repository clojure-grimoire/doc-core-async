{:ns "clojure.core.async", :name "do-alt", :file "clojure/core/async.clj", :type :fn, :src "(defn do-alt [alts clauses]\n  (assert (even? (count clauses)) \"unbalanced clauses\")\n  (let [clauses (core/partition 2 clauses)\n        opt? #(keyword? (first %))\n        opts (filter opt? clauses)\n        clauses (remove opt? clauses)\n        [clauses bindings]\n        (core/reduce\n         (fn [[clauses bindings] [ports expr]]\n           (let [ports (if (vector? ports) ports [ports])\n                 [ports bindings]\n                 (core/reduce\n                  (fn [[ports bindings] port]\n                    (if (vector? port)\n                      (let [[port val] port\n                            gp (gensym)\n                            gv (gensym)]\n                        [(conj ports [gp gv]) (conj bindings [gp port] [gv val])])\n                      (let [gp (gensym)]\n                        [(conj ports gp) (conj bindings [gp port])])))\n                  [[] bindings] ports)]\n             [(conj clauses [ports expr]) bindings]))\n         [[] []] clauses)\n        gch (gensym \"ch\")\n        gret (gensym \"ret\")]\n    `(let [~@(mapcat identity bindings)\n           [val# ~gch :as ~gret] (~alts [~@(apply concat (core/map first clauses))] ~@(apply concat opts))]\n       (cond\n        ~@(mapcat (fn [[ports expr]]\n                    [`(or ~@(core/map (fn [port]\n                                   `(= ~gch ~(if (vector? port) (first port) port)))\n                                 ports))\n                     (if (and (seq? expr) (vector? (first expr)))\n                       `(let [~(first expr) ~gret] ~@(rest expr))\n                       expr)])\n                  clauses)\n        (= ~gch :default) val#))))", :column 1, :line 281, :arglists ([alts clauses])}
{:ns "clojure.core.async", :name "pipeline-async", :file "clojure/core/async.clj", :type :fn, :src "(defn pipeline-async\n  \"Takes elements from the from channel and supplies them to the to\n  channel, subject to the async function af, with parallelism n. af\n  must be a function of two arguments, the first an input value and\n  the second a channel on which to place the result(s). af must close!\n  the channel before returning.  The presumption is that af will\n  return immediately, having launched some asynchronous operation\n  (i.e. in another thread) whose completion/callback will manipulate\n  the result channel. Outputs will be returned in order relative to\n  the inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes. See also\n  pipeline, pipeline-blocking.\"\n  ([n to af from] (pipeline-async n to af from true))\n  ([n to af from close?] (pipeline* n to af from close? nil :async)))", :column 1, :line 523, :arglists ([n to af from] [n to af from close?]), :doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the async function af, with parallelism n. af\n  must be a function of two arguments, the first an input value and\n  the second a channel on which to place the result(s). af must close!\n  the channel before returning.  The presumption is that af will\n  return immediately, having launched some asynchronous operation\n  (i.e. in another thread) whose completion/callback will manipulate\n  the result channel. Outputs will be returned in order relative to\n  the inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes. See also\n  pipeline, pipeline-blocking."}
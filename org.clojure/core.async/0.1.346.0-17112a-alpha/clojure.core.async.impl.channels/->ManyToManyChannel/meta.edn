{:type :fn, :src "(deftype ManyToManyChannel [^LinkedList takes ^LinkedList puts ^Queue buf closed ^Lock mutex add!]\n  MMC\n  (cleanup\n   [_]\n   (when-not (.isEmpty takes)\n     (let [iter (.iterator takes)]\n       (loop [taker (.next iter)]\n         (when-not (impl/active? taker)\n           (.remove iter))\n         (when (.hasNext iter)\n           (recur (.next iter))))))\n   (when-not (.isEmpty puts)\n     (let [iter (.iterator puts)]\n       (loop [[putter] (.next iter)]\n         (when-not (impl/active? putter)\n           (.remove iter))\n         (when (.hasNext iter)\n           (recur (.next iter)))))))\n\n  (abort\n   [this]\n   (let [iter (.iterator puts)]\n     (when (.hasNext iter)\n       (loop [^Lock putter (.next iter)]\n         (.lock putter)\n         (let [put-cb (and (impl/active? putter) (impl/commit putter))]\n           (.unlock putter)\n           (when put-cb\n             (dispatch/run (fn [] (put-cb true))))\n           (when (.hasNext iter)\n             (recur (.next iter)))))))\n   (.clear puts)\n   (impl/close! this))\n\n  impl/WritePort\n  (put!\n   [this val handler]\n   (when (nil? val)\n     (throw (IllegalArgumentException. \"Can't put nil on channel\")))\n   (.lock mutex)\n   (cleanup this)\n   (if @closed\n     (do (.unlock mutex)\n         (box false))\n     (let [^Lock handler handler]\n       (if (and buf (not (impl/full? buf)) (not (.isEmpty takes)))\n         (do\n           (.lock handler)\n           (let [put-cb (and (impl/active? handler) (impl/commit handler))]\n             (.unlock handler)\n             (if put-cb\n               (let [done? (reduced? (add! buf val))]\n                 (if (pos? (count buf))\n                   (let [iter (.iterator takes)\n                         take-cb (when (.hasNext iter)\n                                   (loop [^Lock taker (.next iter)]\n                                     (.lock taker)\n                                     (let [ret (and (impl/active? taker) (impl/commit taker))]\n                                       (.unlock taker)\n                                       (if ret\n                                         (do\n                                           (.remove iter)\n                                           ret)\n                                         (when (.hasNext iter)\n                                           (recur (.next iter)))))))]\n                     (if take-cb\n                       (let [val (impl/remove! buf)]\n                         (when done?\n                           (abort this))\n                         (.unlock mutex)\n                         (dispatch/run (fn [] (take-cb val))))\n                       (do\n                         (when done?\n                           (abort this))\n                         (.unlock mutex))))\n                   (do\n                     (when done?\n                       (abort this))\n                     (.unlock mutex)))\n                 (box true))\n               (do (.unlock mutex)\n                   nil))))\n         (let [iter (.iterator takes)\n               [put-cb take-cb] (when (.hasNext iter)\n                                  (loop [^Lock taker (.next iter)]\n                                    (if (< (impl/lock-id handler) (impl/lock-id taker))\n                                      (do (.lock handler) (.lock taker))\n                                      (do (.lock taker) (.lock handler)))\n                                    (let [ret (when (and (impl/active? handler) (impl/active? taker))\n                                                [(impl/commit handler) (impl/commit taker)])]\n                                      (.unlock handler)\n                                      (.unlock taker)\n                                      (if ret\n                                        (do\n                                          (.remove iter)\n                                          ret)\n                                        (when (.hasNext iter)\n                                          (recur (.next iter)))))))]\n           (if (and put-cb take-cb)\n             (do\n               (.unlock mutex)\n               (dispatch/run (fn [] (take-cb val)))\n               (box true))\n             (if (and buf (not (impl/full? buf)))\n               (do\n                 (.lock handler)\n                 (let [put-cb (and (impl/active? handler) (impl/commit handler))]\n                   (.unlock handler)\n                   (if put-cb\n                     (let [done? (reduced? (add! buf val))]\n                       (when done?\n                         (abort this))\n                       (.unlock mutex)\n                       (box true))\n                     (do (.unlock mutex)\n                         nil))))\n               (do\n                 (when (impl/active? handler)\n                   (assert-unlock mutex\n                                  (< (.size puts) impl/MAX-QUEUE-SIZE)\n                                  (str \"No more than \" impl/MAX-QUEUE-SIZE\n                                       \" pending puts are allowed on a single channel.\"\n                                       \" Consider using a windowed buffer.\"))\n                   (.add puts [handler val]))\n                 (.unlock mutex)\n                 nil))))))))\n  \n  impl/ReadPort\n  (take!\n   [this handler]\n   (.lock mutex)\n   (cleanup this)\n   (let [^Lock handler handler\n         commit-handler (fn []\n                          (.lock handler)\n                          (let [take-cb (and (impl/active? handler) (impl/commit handler))]\n                            (.unlock handler)\n                            take-cb))]\n     (if (and buf (pos? (count buf)))\n       (do\n         (if-let [take-cb (commit-handler)]\n           (let [val (impl/remove! buf)\n                 iter (.iterator puts)\n                 [done? cbs]\n                 (when (.hasNext iter)\n                   (loop [cbs []\n                          [^Lock putter val] (.next iter)]\n                     (.lock putter)\n                     (let [cb (and (impl/active? putter) (impl/commit putter))]\n                       (.unlock putter)\n                       (.remove iter)\n                       (let [cbs (if cb (conj cbs cb) cbs)\n                             done? (when cb (reduced? (add! buf val)))]\n                         (if (and (not done?) (not (impl/full? buf)) (.hasNext iter))\n                           (recur cbs (.next iter))\n                           [done? cbs])))))]\n             (when done?\n               (abort this))\n             (.unlock mutex)\n             (doseq [cb cbs]\n               (dispatch/run #(cb true)))\n             (box val))\n           (do (.unlock mutex)\n               nil)))\n       (let [iter (.iterator puts)\n             [take-cb put-cb val]\n             (when (.hasNext iter)\n               (loop [[^Lock putter val] (.next iter)]\n                 (if (< (impl/lock-id handler) (impl/lock-id putter))\n                   (do (.lock handler) (.lock putter))\n                   (do (.lock putter) (.lock handler)))\n                 (let [ret (when (and (impl/active? handler) (impl/active? putter))\n                             [(impl/commit handler) (impl/commit putter) val])]\n                   (.unlock handler)\n                   (.unlock putter)\n                   (if ret\n                     (do\n                       (.remove iter)\n                       ret)\n                     (when-not (impl/active? putter)\n                       (.remove iter)\n                       (when (.hasNext iter)\n                         (recur (.next iter))))))))]\n         (if (and put-cb take-cb)\n           (do\n             (.unlock mutex)\n             (dispatch/run #(put-cb true))\n             (box val))\n           (if @closed\n             (do\n               (when buf (add! buf))\n               (let [has-val (and buf (pos? (count buf)))]\n                 (if-let [take-cb (commit-handler)]\n                   (let [val (when has-val (impl/remove! buf))]\n                     (.unlock mutex)\n                     (box val))\n                   (do\n                     (.unlock mutex)\n                     nil))))\n             (do\n               (assert-unlock mutex\n                              (< (.size takes) impl/MAX-QUEUE-SIZE)\n                              (str \"No more than \" impl/MAX-QUEUE-SIZE\n                                   \" pending takes are allowed on a single channel.\"))\n               (.add takes handler)\n               (.unlock mutex)\n               nil)))))))\n\n  impl/Channel\n  (closed? [_] @closed)\n  (close!\n   [this]\n   (.lock mutex)\n   (cleanup this)\n   (if @closed\n     (do\n       (.unlock mutex)\n       nil)\n     (do\n       (reset! closed true)\n       (when (and buf (.isEmpty puts))\n         (add! buf))\n       (let [iter (.iterator takes)]\n         (when (.hasNext iter)\n           (loop [^Lock taker (.next iter)]\n             (.lock taker)\n             (let [take-cb (and (impl/active? taker) (impl/commit taker))]\n               (.unlock taker)\n               (when take-cb\n                 (let [val (when (and buf (pos? (count buf))) (impl/remove! buf))]\n                   (dispatch/run (fn [] (take-cb val)))))\n               (.remove iter)\n               (when (.hasNext iter)\n                 (recur (.next iter)))))))\n       (.unlock mutex)\n       nil))))", :ns "clojure.core.async.impl.channels", :name "->ManyToManyChannel", :file "clojure/core/async/impl/channels.clj", :column 1, :line 32, :arglists ([takes puts buf closed mutex add!]), :doc "Positional factory function for class clojure.core.async.impl.channels.ManyToManyChannel."}